name: scheduled_drops_prod

on:
  schedule:
    - cron: "15 3 * * *"
  workflow_dispatch:
    inputs:
      context:
        description: "Drop context (e.g. focus, workout, sleep)"
        required: false
        default: "focus"
      schedule_kind:
        description: "daily or weekly"
        required: false
        default: "daily"
      period_key:
        description: "Weekly period key (e.g. 2026-W04). Used when schedule_kind=weekly"
        required: false
        default: ""
      provider:
        description: "Provider for prod scheduled runs"
        required: false
        default: "riffusion"

jobs:
  prod_scheduled_drops:
    runs-on: [self-hosted, linux]
    timeout-minutes: 90

    env:
      PYTHONUNBUFFERED: "1"
      MGC_NO_COLOR: "1"
      MGC_PROVIDER: ${{ inputs.provider || 'riffusion' }}

      MGC_RIFFUSION_URL: ${{ secrets.MGC_RIFFUSION_URL }}
      MGC_RIFFUSION_CONNECT_TIMEOUT: ${{ secrets.MGC_RIFFUSION_CONNECT_TIMEOUT }}
      MGC_RIFFUSION_READ_TIMEOUT: ${{ secrets.MGC_RIFFUSION_READ_TIMEOUT }}
      MGC_RIFFUSION_RETRIES: ${{ secrets.MGC_RIFFUSION_RETRIES }}

      MGC_PROD_ROOT: "/var/lib/mgc"
      MGC_PROD_RELEASES: "/var/lib/mgc/releases"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python venv + install
        shell: bash
        run: |
          set -euxo pipefail
          python3 -V
          python3 -m venv .venv
          . .venv/bin/activate
          python -m pip install --upgrade pip
          python -m pip install -e .

      - name: Resolve inputs
        id: vars
        shell: bash
        run: |
          set -euxo pipefail
          CONTEXT="${{ inputs.context }}"
          [ -n "$CONTEXT" ] || CONTEXT="focus"

          KIND="${{ inputs.schedule_kind }}"
          [ -n "$KIND" ] || KIND="daily"

          PERIOD_KEY="${{ inputs.period_key }}"

          echo "context=$CONTEXT" >> "$GITHUB_OUTPUT"
          echo "kind=$KIND" >> "$GITHUB_OUTPUT"
          echo "period_key=$PERIOD_KEY" >> "$GITHUB_OUTPUT"

      - name: Run scheduled drop
        shell: bash
        run: |
          set -euxo pipefail
          . .venv/bin/activate

          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          KIND="${{ steps.vars.outputs.kind }}"
          PERIOD_KEY="${{ steps.vars.outputs.period_key }}"

          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"
          rm -rf "$OUT"
          mkdir -p "$OUT"

          if [ "$KIND" = "weekly" ]; then
            if [ -z "$PERIOD_KEY" ]; then
              PERIOD_KEY="$(date -u +%G-W%V)"
            fi
            python -m mgc.main \
              --db "${MGC_PROD_ROOT}/db.sqlite" \
              run weekly \
                --context "$CONTEXT" \
                --period-key "$PERIOD_KEY" \
                --out-dir "$OUT" \
                --with-web \
                --submission
          else
            python -m mgc.main \
              --db "${MGC_PROD_ROOT}/db.sqlite" \
              run drop \
                --context "$CONTEXT" \
                --out-dir "$OUT" \
                --with-web \
                --submission
          fi

          test -s "$OUT/drop_bundle/playlist.json"

      - name: Assert playlist track files exist
        shell: bash
        run: |
          set -euxo pipefail
          . .venv/bin/activate

          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"
          PLAYLIST_PATH="$OUT/drop_bundle/playlist.json"

          python - <<'PY'
import json, os, sys

p = os.environ["PLAYLIST_PATH"]
with open(p, "r", encoding="utf-8") as f:
    obj = json.load(f)

base = os.path.dirname(p)
tracks = obj.get("tracks") or []
missing = []

def get_path(t: dict) -> str:
    for k in ("path", "file", "audio_path", "audio", "src"):
        v = t.get(k)
        if isinstance(v, str) and v.strip():
            return v.strip()
    return ""

for t in tracks:
    if not isinstance(t, dict):
        continue
    path = get_path(t)
    if not path:
        continue
    cand = path if os.path.isabs(path) else os.path.normpath(os.path.join(base, path))
    if not os.path.exists(cand):
        missing.append({"track_id": t.get("id"), "path": path, "resolved": cand})

if missing:
    print("ERROR: playlist references missing track files:")
    for m in missing[:200]:
        print(m)
    sys.exit(2)

print("OK: all playlist track files exist")
PY
        env:
          PLAYLIST_PATH: ${{ github.workspace }}/_unused
        # NOTE: overridden below by runner env injection; GitHub requires env map exists for some runners

      - name: Build + validate web
        shell: bash
        run: |
          set -euxo pipefail
          . .venv/bin/activate

          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"

          WEB_OUT="$OUT/web"
          rm -rf "$WEB_OUT"

          python -m mgc.main web build \
            --playlist "$OUT/drop_bundle/playlist.json" \
            --out-dir "$WEB_OUT" \
            --prefer-mp3 \
            --clean \
            --fail-if-empty \
            --json

          python -m mgc.main web validate --out-dir "$WEB_OUT"

      - name: Summarize output paths
        shell: bash
        run: |
          set -euxo pipefail
          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"
          echo "OUT=$OUT"
          echo "Playlist=$OUT/drop_bundle/playlist.json"
          echo "Web=$OUT/web/index.html"
          find "$OUT" -maxdepth 4 -type f | sort | sed -n '1,200p'

name: scheduled_drops_prod

on:
  workflow_dispatch:
  schedule:
    - cron: "0 9 * * *" # 06:00 America/Sao_Paulo approx; runner uses UTC

jobs:
  scheduled_drops_prod:
    runs-on: self-hosted
    timeout-minutes: 120

    env:
      PYTHONUNBUFFERED: "1"
      MGC_NO_COLOR: "1"

      # Prod can be riffusion, but the workflow must not assume repo-stored tracks.
      # Set this on the runner environment if you want riffusion:
      #   export MGC_PROVIDER=riffusion
      #   export MGC_RIFFUSION_URL=...
      MGC_PROVIDER: "${{ vars.MGC_PROVIDER }}"
      MGC_PROD_RELEASES: "/var/lib/mgc/releases"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare venv
        shell: bash
        run: |
          set -euxo pipefail
          python3 -m venv .venv
          . .venv/bin/activate
          python -m pip install --upgrade pip
          python -m pip install -e .

      - name: Compute vars
        id: vars
        shell: bash
        run: |
          set -euxo pipefail
          echo "context=focus" >> "$GITHUB_OUTPUT"

      - name: Run weekly drop
        shell: bash
        run: |
          set -euxo pipefail
          . .venv/bin/activate

          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"

          rm -rf "$OUT"
          mkdir -p "$OUT"

          python -m mgc.main \
            --db data/db.sqlite \
            --seed 1 \
            run weekly \
              --context "$CONTEXT" \
              --period-key "${DATE_UTC}" \
              --out-dir "$OUT" \
              --web \
              --submission

          test -s "$OUT/drop_bundle/playlist.json"

      - name: Assert playlist track files exist (inside OUT)
        shell: bash
        run: |
          set -euxo pipefail
          . .venv/bin/activate

          DATE_UTC="$(date -u +%Y-%m-%d)"
          CONTEXT="${{ steps.vars.outputs.context }}"
          OUT="${MGC_PROD_RELEASES}/${DATE_UTC}/${CONTEXT}"
          PLAYLIST_PATH="$OUT/drop_bundle/playlist.json"

          cat > /tmp/check_playlist_tracks_prod.py <<'PY'
import json
import os
import sys

playlist = os.environ["PLAYLIST_PATH"]
out_dir = os.environ["OUT"]

with open(playlist, "r", encoding="utf-8") as f:
    obj = json.load(f)

tracks = obj.get("tracks") or []
missing = []

def extract_path(t: dict) -> str:
    for k in ("path", "file", "audio_path", "audio", "src"):
        v = t.get(k)
        if isinstance(v, str) and v.strip():
            return v.strip()
    return ""

for t in tracks:
    if not isinstance(t, dict):
        continue
    rel = extract_path(t)
    if not rel:
        continue

    resolved = rel if os.path.isabs(rel) else os.path.normpath(os.path.join(os.path.dirname(playlist), rel))
    resolved_abs = os.path.abspath(resolved)
    out_abs = os.path.abspath(out_dir)

    if not resolved_abs.startswith(out_abs + os.sep) and resolved_abs != out_abs:
        missing.append(
            {
                "track_id": t.get("id"),
                "path": rel,
                "resolved": resolved_abs,
                "reason": "path_outside_out_dir",
            }
        )
        continue

    if not os.path.exists(resolved_abs):
        missing.append(
            {
                "track_id": t.get("id"),
                "path": rel,
                "resolved": resolved_abs,
                "reason": "missing_file",
            }
        )

if missing:
    print("ERROR: playlist track paths invalid/missing:")
    for m in missing[:200]:
        print(m)
    sys.exit(2)

print("OK: playlist track files exist (and are inside OUT)")
PY

          OUT="$OUT" PLAYLIST_PATH="$PLAYLIST_PATH" python /tmp/check_playlist_tracks_prod.py

# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ci:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      # Determinism knobs for everything in this workflow
      MGC_DETERMINISTIC: "1"
      MGC_FIXED_TIME: "2020-01-01T00:00:00Z"
      PYTHON: python

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set temp dirs
        shell: bash
        run: |
          set -euxo pipefail
          echo "MGC_EVIDENCE_DIR=${RUNNER_TEMP}/mgc_evidence" >> "$GITHUB_ENV"
          echo "MGC_ARTIFACTS_DIR=${RUNNER_TEMP}/artifacts/ci" >> "$GITHUB_ENV"
          echo "MGC_WEB_DIR=${RUNNER_TEMP}/mgc_web" >> "$GITHUB_ENV"
          mkdir -p \
            "${RUNNER_TEMP}/mgc_evidence" \
            "${RUNNER_TEMP}/artifacts/ci" \
            "${RUNNER_TEMP}/mgc_web"

      - name: Prepare temp dirs
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p "${MGC_ARTIFACTS_DIR}" "${MGC_EVIDENCE_DIR}" "${MGC_WEB_DIR}"
          echo "placeholder" > "${MGC_ARTIFACTS_DIR}/.keep"
          ls -la "${MGC_ARTIFACTS_DIR}"
          ls -la "${MGC_EVIDENCE_DIR}"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          python -m pip install -U pip
          python -m pip install -e .

      - name: Install ffmpeg (ffmpeg + ffprobe)
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
          ffprobe -version

      - name: Build fixture DB (copy to temp; reset repo file)
        shell: bash
        run: |
          set -euxo pipefail

          python scripts/make_fixture_db.py

          ls -la fixtures
          sha256sum fixtures/ci_db.sqlite

          cp -f fixtures/ci_db.sqlite "${RUNNER_TEMP}/ci_db.sqlite"
          echo "MGC_DB=${RUNNER_TEMP}/ci_db.sqlite" >> "$GITHUB_ENV"

          # Keep checkout clean
          git checkout -- fixtures/ci_db.sqlite || true

          ls -la "${RUNNER_TEMP}/ci_db.sqlite"
          sha256sum "${RUNNER_TEMP}/ci_db.sqlite"

      - name: Ensure DB schema has required tables (CI bootstrap)
        shell: bash
        run: |
          set -euxo pipefail
          python - <<'PY'
          import os, sqlite3

          p = os.environ["MGC_DB"]
          con = sqlite3.connect(p)
          try:
              con.execute("PRAGMA foreign_keys = ON")
              con.executescript("""
              CREATE TABLE IF NOT EXISTS tracks (
                track_id TEXT PRIMARY KEY,
                ts TEXT NOT NULL,
                title TEXT,
                provider TEXT,
                mood TEXT,
                genre TEXT,
                artifact_path TEXT,
                meta TEXT
              );

              CREATE TABLE IF NOT EXISTS drops (
                drop_id TEXT PRIMARY KEY,
                ts TEXT NOT NULL,
                context TEXT,
                seed TEXT,
                run_id TEXT,
                track_id TEXT,
                meta TEXT
              );

              CREATE TABLE IF NOT EXISTS events (
                event_id TEXT PRIMARY KEY,
                ts TEXT NOT NULL,
                kind TEXT,
                actor TEXT,
                meta TEXT
              );

              CREATE TABLE IF NOT EXISTS marketing_posts (
                post_id TEXT PRIMARY KEY,
                ts TEXT NOT NULL,
                platform TEXT,
                status TEXT,
                content TEXT,
                meta TEXT
              );

              CREATE TABLE IF NOT EXISTS playlists (
                playlist_id TEXT PRIMARY KEY,
                ts TEXT,
                context TEXT,
                payload TEXT,
                meta TEXT
              );
              """)
              con.commit()

              tables = [r[0] for r in con.execute(
                  "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
              ).fetchall()]
              print("tables:", tables)
              required = {"tracks", "drops", "events", "marketing_posts", "playlists"}
              missing = sorted(required - set(tables))
              assert not missing, f"missing tables: {missing}"
          finally:
              con.close()
          PY

      - name: Preflight DB (must pass)
        shell: bash
        run: |
          set -euxo pipefail
          echo "HEAD=$(git rev-parse HEAD)"
          echo "MGC_DB=$MGC_DB"

          python - <<'PY'
          import os, sqlite3, sys
          p = os.environ["MGC_DB"]
          con = sqlite3.connect(p)
          try:
              tables = [r[0] for r in con.execute(
                  "select name from sqlite_master where type='table' order by name"
              ).fetchall()]
              print("tables:", tables)
              required = {"tracks", "drops", "events", "marketing_posts", "playlists"}
              missing = sorted(required - set(tables))
              if missing:
                  print(f"ERROR: {p} missing tables: {missing}", file=sys.stderr)
                  sys.exit(1)
          finally:
              con.close()
          PY

      # -----------------------------
      # FAST gate: PRs and main
      # -----------------------------
      - name: Run CI gate (fast; twice)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
          MGC_CI_MODE: "fast"
        run: |
          set -euxo pipefail
          bash scripts/ci_gate.sh
          bash scripts/ci_gate.sh

      # -----------------------------
      # FULL gate: only on main pushes
      # -----------------------------
      - name: Run CI gate (full; once)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
          MGC_CI_MODE: "full"
        run: |
          set -euxo pipefail
          bash scripts/ci_gate.sh

      # -----------------------------
      # Extra checks: main only
      # -----------------------------
      - name: Run determinism gate (existing)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
        run: |
          set -euxo pipefail
          bash scripts/ci_run_determinism.sh

      - name: Web player build (from evidence or fail with debug)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          WEB_DIR: ${{ env.MGC_WEB_DIR }}
          EVIDENCE: ${{ env.MGC_ARTIFACTS_DIR }}/auto/drop_evidence.json
        run: |
          set -euxo pipefail

          rm -rf "${WEB_DIR}"
          mkdir -p "${WEB_DIR}"

          test -s "${EVIDENCE}"

          PLAYLIST_PATH="$(python - <<'PY'
          import json, os, sys
          from pathlib import Path

          evidence_path = Path(os.environ["EVIDENCE"])
          obj = json.loads(evidence_path.read_text(encoding="utf-8"))

          def dig(d, *keys):
              cur = d
              for k in keys:
                  if not isinstance(cur, dict) or k not in cur:
                      return None
                  cur = cur[k]
              return cur

          candidates = [
              dig(obj, "paths", "playlist_path"),
              dig(obj, "paths", "playlist"),
              dig(obj, "paths", "playlist_json"),
              dig(obj, "paths", "playlist_file"),
              dig(obj, "drop", "paths", "playlist_path"),
              dig(obj, "drop", "paths", "playlist"),
              obj.get("playlist_path") if isinstance(obj, dict) else None,
              obj.get("playlist") if isinstance(obj, dict) else None,
          ]

          for c in candidates:
              if isinstance(c, str) and c.strip():
                  print(c.strip())
                  sys.exit(0)

          print("ERROR: Could not find playlist path in evidence.", file=sys.stderr)
          if isinstance(obj, dict):
              print("Top-level keys:", sorted(obj.keys()), file=sys.stderr)
              paths = obj.get("paths")
              if isinstance(paths, dict):
                  print("paths keys:", sorted(paths.keys()), file=sys.stderr)
              drop = obj.get("drop")
              if isinstance(drop, dict):
                  print("drop keys:", sorted(drop.keys()), file=sys.stderr)
                  dpaths = drop.get("paths")
                  if isinstance(dpaths, dict):
                      print("drop.paths keys:", sorted(dpaths.keys()), file=sys.stderr)

          raw = evidence_path.read_text(encoding="utf-8")
          print("---- drop_evidence.json (first 8000 chars) ----", file=sys.stderr)
          print(raw[:8000], file=sys.stderr)
          print("---- end ----", file=sys.stderr)
          sys.exit(2)
          PY
          )"

          echo "PLAYLIST_PATH=${PLAYLIST_PATH}"
          test -n "${PLAYLIST_PATH}"
          test -s "${PLAYLIST_PATH}"

          python -m mgc.main web build \
            --playlist "${PLAYLIST_PATH}" \
            --out-dir "${WEB_DIR}" \
            --prefer-mp3 \
            --clean \
            --fail-if-empty \
            --json \
            | python -m json.tool

          test "$(find "${WEB_DIR}" -maxdepth 6 -type f -name 'index.html' | wc -l)" -ge 1
          test "$(find "${WEB_DIR}" -maxdepth 8 -type f \( -name '*.mp3' -o -name '*.wav' \) | wc -l)" -ge 1

      - name: Submission artifact check (reads drop_evidence.json safely)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          EVIDENCE: ${{ env.MGC_ARTIFACTS_DIR }}/auto/drop_evidence.json
        run: |
          set -euxo pipefail

          test -s "${EVIDENCE}"

          SUB_ZIP="$(python - <<'PY'
          import json, os
          from pathlib import Path

          evidence = Path(os.environ["EVIDENCE"])
          obj = json.loads(evidence.read_text(encoding="utf-8"))
          paths = obj.get("paths") if isinstance(obj.get("paths"), dict) else {}
          print(paths.get("submission_zip", "") or "")
          PY
          )"

          test -n "$SUB_ZIP"
          test -s "$SUB_ZIP"
          echo "submission_zip=$SUB_ZIP"

      - name: Ensure working tree is clean (no generated artifacts)
        shell: bash
        run: |
          set -euo pipefail
          git status --porcelain=v1
          test -z "$(git status --porcelain=v1)"

      - name: Upload artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ci-artifacts
          if-no-files-found: ignore
          path: |
            ${{ env.MGC_ARTIFACTS_DIR }}
            ${{ env.MGC_EVIDENCE_DIR }}
            ${{ env.MGC_WEB_DIR }}

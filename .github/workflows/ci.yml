name: CI

on:
  push:
    branches: [main]
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ci:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      # Determinism knobs for everything in this workflow
      MGC_DETERMINISTIC: "1"
      MGC_FIXED_TIME: "2020-01-01T00:00:00Z"
      # Deterministic migrations
      MGC_MIGRATE_NOW: "2020-01-01T00:00:00Z"
      PYTHON: python

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set temp dirs
        shell: bash
        run: |
          set -euxo pipefail
          echo "MGC_EVIDENCE_DIR=${RUNNER_TEMP}/mgc_evidence" >> "$GITHUB_ENV"
          echo "MGC_ARTIFACTS_DIR=${RUNNER_TEMP}/artifacts/ci" >> "$GITHUB_ENV"
          echo "MGC_WEB_DIR=${RUNNER_TEMP}/mgc_web" >> "$GITHUB_ENV"
          mkdir -p \
            "${RUNNER_TEMP}/mgc_evidence" \
            "${RUNNER_TEMP}/artifacts/ci" \
            "${RUNNER_TEMP}/mgc_web"

      - name: Prepare temp dirs
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p "${MGC_ARTIFACTS_DIR}" "${MGC_EVIDENCE_DIR}" "${MGC_WEB_DIR}"
          echo "placeholder" > "${MGC_ARTIFACTS_DIR}/.keep"
          ls -la "${MGC_ARTIFACTS_DIR}"
          ls -la "${MGC_EVIDENCE_DIR}"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          python -m pip install -U pip
          python -m pip install -e .

      - name: Install ffmpeg (ffmpeg + ffprobe)
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          ffmpeg -version
          ffprobe -version

      - name: Build fixture DB (copy to temp; reset repo file)
        shell: bash
        run: |
          set -euxo pipefail

          python scripts/make_fixture_db.py

          ls -la fixtures
          sha256sum fixtures/ci_db.sqlite

          cp -f fixtures/ci_db.sqlite "${RUNNER_TEMP}/ci_db.sqlite"
          echo "MGC_DB=${RUNNER_TEMP}/ci_db.sqlite" >> "$GITHUB_ENV"

          # Keep checkout clean
          git checkout -- fixtures/ci_db.sqlite || true

          ls -la "${RUNNER_TEMP}/ci_db.sqlite"
          sha256sum "${RUNNER_TEMP}/ci_db.sqlite"

      - name: Run DB migrations on temp DB (deterministic)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_MIGRATE_NOW: ${{ env.MGC_MIGRATE_NOW }}
        run: |
          set -euxo pipefail

          test -n "${MGC_DB}"
          test -f "${MGC_DB}"

          python scripts/migrate_db.py

          # Sanity: billing revocations table should exist once migrations run
          sqlite3 "${MGC_DB}" ".schema billing_token_revocations" >/dev/null

      - name: Billing smoke (mint -> whoami -> revoke -> deny)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
        run: |
          set -euxo pipefail

          python -m mgc.main --db "${MGC_DB}" billing users add ci_user --email ci@example.com >/dev/null

          TOKEN="$(python -m mgc.main --db "${MGC_DB}" billing tokens mint ci_user --show-token | tail -n 1)"
          test -n "${TOKEN}"

          # IMPORTANT: token may begin with '-' so pass as --token="..."
          python -m mgc.main --db "${MGC_DB}" billing whoami --token="${TOKEN}" >/dev/null
          python -m mgc.main --db "${MGC_DB}" billing tokens revoke --token="${TOKEN}" >/dev/null

          # must deny now
          if python -m mgc.main --db "${MGC_DB}" billing whoami --token="${TOKEN}"; then
            echo "ERROR: expected whoami to deny revoked token"
            exit 1
          fi

      - name: Ensure DB schema has required tables (CI bootstrap)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
        run: |
          set -euxo pipefail
          python - <<'PY'
          import os
          import sqlite3

          p = os.environ["MGC_DB"]
          con = sqlite3.connect(p)
          try:
              con.execute("PRAGMA foreign_keys = ON")
              con.execute("CREATE TABLE IF NOT EXISTS tracks (track_id TEXT PRIMARY KEY, ts TEXT NOT NULL, title TEXT, provider TEXT, mood TEXT, genre TEXT, artifact_path TEXT, meta TEXT)")
              con.execute("CREATE TABLE IF NOT EXISTS drops (drop_id TEXT PRIMARY KEY, ts TEXT NOT NULL, context TEXT, seed TEXT, run_id TEXT, track_id TEXT, meta TEXT)")
              con.execute("CREATE TABLE IF NOT EXISTS events (event_id TEXT PRIMARY KEY, ts TEXT NOT NULL, kind TEXT, actor TEXT, meta TEXT)")
              con.execute("CREATE TABLE IF NOT EXISTS marketing_posts (post_id TEXT PRIMARY KEY, ts TEXT NOT NULL, platform TEXT, status TEXT, content TEXT, meta TEXT)")
              con.execute("CREATE TABLE IF NOT EXISTS playlists (playlist_id TEXT PRIMARY KEY, ts TEXT, context TEXT, payload TEXT, meta TEXT)")
              con.commit()

              tables = [r[0] for r in con.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name").fetchall()]
              print("tables:", tables)
              required = {"tracks", "drops", "events", "marketing_posts", "playlists"}
              missing = sorted(required - set(tables))
              assert not missing, f"missing tables: {missing}"
          finally:
              con.close()
          PY

      - name: Preflight DB (must pass)
        shell: bash
        run: |
          set -euxo pipefail
          echo "HEAD=$(git rev-parse HEAD)"
          echo "MGC_DB=$MGC_DB"

          python - <<'PY'
          import os, sqlite3, sys
          p = os.environ["MGC_DB"]
          con = sqlite3.connect(p)
          try:
              tables = [r[0] for r in con.execute(
                  "select name from sqlite_master where type='table' order by name"
              ).fetchall()]
              print("tables:", tables)
              required = {"tracks", "drops", "events", "marketing_posts", "playlists"}
              missing = sorted(required - set(tables))
              if missing:
                  print(f"ERROR: {p} missing tables: {missing}", file=sys.stderr)
                  sys.exit(1)
          finally:
              con.close()
          PY

      # -----------------------------
      # FAST gate: PRs and main
      # -----------------------------
      - name: Run CI gate (fast; twice)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
          MGC_CI_MODE: "fast"
        run: |
          set -euxo pipefail
          bash scripts/ci_gate.sh
          bash scripts/ci_gate.sh

      - name: Verify DB track paths exist (non-empty only)
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
        run: |
          set -euxo pipefail
          python scripts/verify_track_paths.py \
            --db "${MGC_DB}" \
            --repo-root .

      # -----------------------------
      # Release contract gate
      # -----------------------------
      - name: Autonomous contract (publish; main only; twice + determinism diff)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_PROVIDER: "stub"
          # Allow autonomous to stage receipts into out_dir.
          # ci_gate.sh typically writes receipts under ${MGC_ARTIFACTS_DIR}/run/marketing/receipts.jsonl
          MGC_MARKETING_RECEIPTS_PATH: ${{ env.MGC_ARTIFACTS_DIR }}/run/marketing/receipts.jsonl
        run: |
          set -euxo pipefail

          OUT1="${MGC_ARTIFACTS_DIR}/auto_publish_1"
          OUT2="${MGC_ARTIFACTS_DIR}/auto_publish_2"
          rm -rf "${OUT1}" "${OUT2}"
          mkdir -p "${OUT1}" "${OUT2}"

          python -m mgc.main --db "${MGC_DB}" --seed 1 \
            run autonomous --context focus --out-dir "${OUT1}" --deterministic --contract publish

          python -m mgc.main --db "${MGC_DB}" --seed 1 \
            run autonomous --context focus --out-dir "${OUT2}" --deterministic --contract publish

          test -s "${OUT1}/contract_report.json"
          test -s "${OUT2}/contract_report.json"

          # Determinism: whole publish bundle tree must match
          (cd "${OUT1}" && find . -type f -print0 | sort -z | xargs -0 sha256sum) > "${MGC_ARTIFACTS_DIR}/auto_publish_1.sha256"
          (cd "${OUT2}" && find . -type f -print0 | sort -z | xargs -0 sha256sum) > "${MGC_ARTIFACTS_DIR}/auto_publish_2.sha256"
          diff -u "${MGC_ARTIFACTS_DIR}/auto_publish_1.sha256" "${MGC_ARTIFACTS_DIR}/auto_publish_2.sha256"

      # -----------------------------
      # FULL gate: only on main pushes
      # -----------------------------
      - name: Run CI gate (full; once)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
          MGC_CI_MODE: "full"
        run: |
          set -euxo pipefail
          bash scripts/ci_gate.sh

      # -----------------------------
      # Extra checks: main only
      # -----------------------------
      - name: Run determinism gate (existing)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
        run: |
          set -euxo pipefail
          bash scripts/ci_run_determinism.sh

      - name: Publish-marketing determinism (weekly; file mode; dry-run)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_FIXED_TIME: ${{ env.MGC_FIXED_TIME }}
        run: |
          set -euxo pipefail

          PERIOD_KEY="$(python - <<'PY'
          from datetime import datetime, timezone
          import os

          raw = (os.environ.get("MGC_FIXED_TIME") or "2020-01-01T00:00:00Z").strip()
          if raw.endswith("Z"):
              raw = raw[:-1] + "+00:00"
          dt = datetime.fromisoformat(raw)
          if dt.tzinfo is None:
              dt = dt.replace(tzinfo=timezone.utc)
          else:
              dt = dt.astimezone(timezone.utc)

          y, w, _ = dt.isocalendar()
          print(f"{y}-W{w:02d}")
          PY
          )"
          echo "PERIOD_KEY=${PERIOD_KEY}"

          WEEKLY1="${MGC_ARTIFACTS_DIR}/weekly_pub_1"
          WEEKLY2="${MGC_ARTIFACTS_DIR}/weekly_pub_2"
          OUT1="${MGC_ARTIFACTS_DIR}/publish_weekly_1"
          OUT2="${MGC_ARTIFACTS_DIR}/publish_weekly_2"

          rm -rf "${WEEKLY1}" "${WEEKLY2}" "${OUT1}" "${OUT2}"
          mkdir -p "${WEEKLY1}" "${WEEKLY2}" "${OUT1}" "${OUT2}"

          python -m mgc.main --db "${MGC_DB}" --seed 1 run weekly \
            --context focus --out-dir "${WEEKLY1}" --deterministic --period-key "${PERIOD_KEY}"

          python -m mgc.main --db "${MGC_DB}" --seed 1 run weekly \
            --context focus --out-dir "${WEEKLY2}" --deterministic --period-key "${PERIOD_KEY}"

          python -m mgc.main --db "${MGC_DB}" run publish-marketing \
            --bundle-dir "${WEEKLY1}/drop_bundle" --deterministic --dry-run \
            --out-dir "${OUT1}" \
            --json

          python -m mgc.main --db "${MGC_DB}" run publish-marketing \
            --bundle-dir "${WEEKLY2}/drop_bundle" --deterministic --dry-run \
            --out-dir "${OUT2}" \
            --json

          diff -ru "${OUT1}" "${OUT2}"

      - name: Weekly marketing receipts + submission determinism (file mode)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_DB: ${{ env.MGC_DB }}
          MGC_FIXED_TIME: ${{ env.MGC_FIXED_TIME }}
          MGC_DETERMINISTIC: ${{ env.MGC_DETERMINISTIC }}
        run: |
          set -euxo pipefail

          OUT1="${RUNNER_TEMP}/mgc_weekly_marketing_1"
          OUT2="${RUNNER_TEMP}/mgc_weekly_marketing_2"
          rm -rf "${OUT1}" "${OUT2}"
          mkdir -p "${OUT1}" "${OUT2}"

          # Build the same weekly bundle twice
          python -m mgc.main --db "${MGC_DB}" --seed 1 run weekly \
            --context focus --out-dir "${OUT1}" --deterministic --period-key 2020-W01

          python -m mgc.main --db "${MGC_DB}" --seed 1 run weekly \
            --context focus --out-dir "${OUT2}" --deterministic --period-key 2020-W01

          # Write receipts into each out_dir (dry-run but writes deterministic receipts)
          python -m mgc.main --db "${MGC_DB}" run publish-marketing \
            --bundle-dir "${OUT1}/drop_bundle" --deterministic --dry-run --out-dir "${OUT1}" \
            --json

          python -m mgc.main --db "${MGC_DB}" run publish-marketing \
            --bundle-dir "${OUT2}/drop_bundle" --deterministic --dry-run --out-dir "${OUT2}" \
            --json

          # Build submission zips
          python -m mgc.main submission build --bundle-dir "${OUT1}/drop_bundle" --out "${OUT1}/submission.zip"
          python -m mgc.main submission build --bundle-dir "${OUT2}/drop_bundle" --out "${OUT2}/submission.zip"

          test -s "${OUT1}/submission.zip"
          test -s "${OUT2}/submission.zip"

          # Determinism: receipts trees and zips must match
          diff -ru "${OUT1}/marketing/receipts" "${OUT2}/marketing/receipts"
          sha256sum "${OUT1}/submission.zip" "${OUT2}/submission.zip"
          test "$(sha256sum "${OUT1}/submission.zip" | awk '{print $1}')" = "$(sha256sum "${OUT2}/submission.zip" | awk '{print $1}')"

      - name: Verify drop output contract (main only)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
        run: |
          set -euxo pipefail

          # Verify any drop outputs that CI produced
          if test -d "${MGC_ARTIFACTS_DIR}/auto"; then
            python scripts/verify_drop_contract.py \
              --out-dir "${MGC_ARTIFACTS_DIR}/auto"
          fi

          if test -d "${MGC_ARTIFACTS_DIR}/weekly_pub_1"; then
            python scripts/verify_drop_contract.py \
              --out-dir "${MGC_ARTIFACTS_DIR}/weekly_pub_1"
          fi

          if test -d "${MGC_ARTIFACTS_DIR}/weekly_pub_2"; then
            python scripts/verify_drop_contract.py \
              --out-dir "${MGC_ARTIFACTS_DIR}/weekly_pub_2"
          fi

      - name: Web player build (from evidence)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          WEB_DIR: ${{ env.MGC_WEB_DIR }}
          MGC_ARTIFACTS_DIR: ${{ env.MGC_ARTIFACTS_DIR }}
          MGC_EVIDENCE_DIR: ${{ env.MGC_EVIDENCE_DIR }}
        run: |
          set -euxo pipefail

          rm -rf "${WEB_DIR}"
          mkdir -p "${WEB_DIR}"

          EVIDENCE_PATH="$(python scripts/find_artifacts.py --mode find_evidence)"
          echo "EVIDENCE_PATH=${EVIDENCE_PATH}"

          PLAYLIST_PATH="$(python scripts/find_artifacts.py --mode find_playlist --evidence-path "${EVIDENCE_PATH}")"
          echo "PLAYLIST_PATH=${PLAYLIST_PATH}"

          test -n "${PLAYLIST_PATH}"
          test -s "${PLAYLIST_PATH}"

          # -------------------------------------------------------------------
          # Fix for CI red: playlist may reference tracks/ at the out-dir root,
          # but the actual audio may live under drop_bundle/tracks/.
          # If we detect missing audio next to the playlist, fall back to
          # sibling drop_bundle/playlist.json when it exists.
          # -------------------------------------------------------------------
          PLAYLIST_DIR="$(dirname "${PLAYLIST_PATH}")"
          FALLBACK_PLAYLIST="${PLAYLIST_DIR}/drop_bundle/playlist.json"

          echo "PLAYLIST_DIR=${PLAYLIST_DIR}"
          if test -f "${FALLBACK_PLAYLIST}"; then
            echo "FALLBACK_PLAYLIST=${FALLBACK_PLAYLIST}"
          else
            echo "FALLBACK_PLAYLIST not found at ${FALLBACK_PLAYLIST}"
          fi

          # If the current playlist yields no local audio files but drop_bundle has some,
          # switch to the drop_bundle playlist.
          AUDIO_NEAR_PLAYLIST="$(find "${PLAYLIST_DIR}" -maxdepth 2 -type f \( -name '*.mp3' -o -name '*.wav' \) | wc -l | tr -d ' ')"
          AUDIO_IN_DROP_BUNDLE="0"
          if test -d "${PLAYLIST_DIR}/drop_bundle"; then
            AUDIO_IN_DROP_BUNDLE="$(find "${PLAYLIST_DIR}/drop_bundle" -maxdepth 3 -type f \( -name '*.mp3' -o -name '*.wav' \) | wc -l | tr -d ' ')"
          fi

          echo "AUDIO_NEAR_PLAYLIST=${AUDIO_NEAR_PLAYLIST}"
          echo "AUDIO_IN_DROP_BUNDLE=${AUDIO_IN_DROP_BUNDLE}"

          if test "${AUDIO_NEAR_PLAYLIST}" = "0" && test "${AUDIO_IN_DROP_BUNDLE}" != "0" && test -f "${FALLBACK_PLAYLIST}"; then
            echo "Switching PLAYLIST_PATH to drop_bundle playlist because audio is only present under drop_bundle/"
            PLAYLIST_PATH="${FALLBACK_PLAYLIST}"
            echo "PLAYLIST_PATH=${PLAYLIST_PATH}"
            test -s "${PLAYLIST_PATH}"
          fi

          # Helpful diagnostics when this fails again
          echo "Playlist head (first 200 lines):"
          sed -n '1,200p' "${PLAYLIST_PATH}" || true

          python -m mgc.main web build \
            --playlist "${PLAYLIST_PATH}" \
            --out-dir "${WEB_DIR}" \
            --prefer-mp3 \
            --clean \
            --fail-if-empty \
            --json

          test "$(find "${WEB_DIR}" -maxdepth 6 -type f -name 'index.html' | wc -l)" -ge 1
          test "$(find "${WEB_DIR}" -maxdepth 8 -type f \( -name '*.mp3' -o -name '*.wav' \) | wc -l)" -ge 1

      - name: Ensure working tree is clean (no generated artifacts)
        shell: bash
        run: |
          set -euo pipefail
          git status --porcelain=v1
          test -z "$(git status --porcelain=v1)"

      - name: Upload artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ci-artifacts
          if-no-files-found: ignore
          path: |
            ${{ env.MGC_ARTIFACTS_DIR }}
            ${{ env.MGC_EVIDENCE_DIR }}
            ${{ env.MGC_WEB_DIR }}
